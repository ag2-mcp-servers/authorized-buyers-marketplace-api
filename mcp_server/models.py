# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T00:57:56+00:00

from __future__ import annotations

from enum import Enum
from typing import List, Optional

from pydantic import BaseModel, Field


class AcceptProposalRequest(BaseModel):
    proposalRevision: Optional[str] = Field(
        None, description='The last known client revision number of the proposal.'
    )


class ActivateClientRequest(BaseModel):
    pass


class ActivateClientUserRequest(BaseModel):
    pass


class Type(Enum):
    TYPE_UNSPECIFIED = 'TYPE_UNSPECIFIED'
    PIXEL = 'PIXEL'
    INTERSTITIAL = 'INTERSTITIAL'
    NATIVE = 'NATIVE'
    FLUID = 'FLUID'


class AdSize(BaseModel):
    height: Optional[str] = Field(
        None,
        description='The height of the ad slot in pixels. This field will be present only when size type is `PIXEL`.',
    )
    type: Optional[Type] = Field(None, description='The type of the ad slot size.')
    width: Optional[str] = Field(
        None,
        description='The width of the ad slot in pixels. This field will be present only when size type is `PIXEL`.',
    )


class AddCreativeRequest(BaseModel):
    creative: Optional[str] = Field(
        None,
        description='Name of the creative to add to the finalized deal, in the format `buyers/{buyerAccountId}/creatives/{creativeId}`. See creative.name.',
    )


class AuctionPackage(BaseModel):
    createTime: Optional[str] = Field(
        None, description='Output only. Time the auction package was created.'
    )
    creator: Optional[str] = Field(
        None,
        description='Output only. The buyer that created this auction package. Format: `buyers/{buyerAccountId}`',
    )
    description: Optional[str] = Field(
        None, description='Output only. A description of the auction package.'
    )
    displayName: Optional[str] = Field(
        None, description='The display_name assigned to the auction package.'
    )
    name: Optional[str] = Field(
        None,
        description='Immutable. The unique identifier for the auction package. Format: `buyers/{accountId}/auctionPackages/{auctionPackageId}` The auction_package_id part of name is sent in the BidRequest to all RTB bidders and is returned as deal_id by the bidder in the BidResponse.',
    )
    subscribedClients: Optional[List[str]] = Field(
        None,
        description='Output only. The list of clients of the current buyer that are subscribed to the AuctionPackage. Format: `buyers/{buyerAccountId}/clients/{clientAccountId}`',
    )
    updateTime: Optional[str] = Field(
        None,
        description='Output only. Time the auction package was last updated. This value is only increased when this auction package is updated but never when a buyer subscribed.',
    )


class CancelNegotiationRequest(BaseModel):
    pass


class Role(Enum):
    CLIENT_ROLE_UNSPECIFIED = 'CLIENT_ROLE_UNSPECIFIED'
    CLIENT_DEAL_VIEWER = 'CLIENT_DEAL_VIEWER'
    CLIENT_DEAL_NEGOTIATOR = 'CLIENT_DEAL_NEGOTIATOR'
    CLIENT_DEAL_APPROVER = 'CLIENT_DEAL_APPROVER'


class State(Enum):
    STATE_UNSPECIFIED = 'STATE_UNSPECIFIED'
    ACTIVE = 'ACTIVE'
    INACTIVE = 'INACTIVE'


class Client(BaseModel):
    displayName: Optional[str] = Field(
        None,
        description='Required. Display name shown to publishers. Must be unique for clients without partnerClientId specified. Maximum length of 255 characters is allowed.',
    )
    name: Optional[str] = Field(
        None,
        description='Output only. The resource name of the client. Format: `buyers/{accountId}/clients/{clientAccountId}`',
    )
    partnerClientId: Optional[str] = Field(
        None,
        description='Arbitrary unique identifier provided by the buyer. This field can be used to associate a client with an identifier in the namespace of the buyer, lookup clients by that identifier and verify whether an Authorized Buyers account of the client already exists. If present, must be unique across all the clients.',
    )
    role: Optional[Role] = Field(
        None,
        description='Required. The role assigned to the client. Each role implies a set of permissions granted to the client.',
    )
    sellerVisible: Optional[bool] = Field(
        None, description='Whether the client will be visible to sellers.'
    )
    state: Optional[State] = Field(
        None, description='Output only. The state of the client.'
    )


class State1(Enum):
    STATE_UNSPECIFIED = 'STATE_UNSPECIFIED'
    INVITED = 'INVITED'
    ACTIVE = 'ACTIVE'
    INACTIVE = 'INACTIVE'


class ClientUser(BaseModel):
    email: Optional[str] = Field(
        None,
        description="Required. The client user's email address that has to be unique across all users for the same client.",
    )
    name: Optional[str] = Field(
        None,
        description='Output only. The resource name of the client user. Format: `buyers/{accountId}/clients/{clientAccountId}/users/{userId}`',
    )
    state: Optional[State1] = Field(
        None, description='Output only. The state of the client user.'
    )


class Contact(BaseModel):
    displayName: Optional[str] = Field(
        None, description='The display_name of the contact.'
    )
    email: Optional[str] = Field(None, description='Email address for the contact.')


class CreativeFormat(Enum):
    CREATIVE_FORMAT_UNSPECIFIED = 'CREATIVE_FORMAT_UNSPECIFIED'
    DISPLAY = 'DISPLAY'
    VIDEO = 'VIDEO'


class CreativePreApprovalPolicy(Enum):
    CREATIVE_PRE_APPROVAL_POLICY_UNSPECIFIED = (
        'CREATIVE_PRE_APPROVAL_POLICY_UNSPECIFIED'
    )
    SELLER_PRE_APPROVAL_REQUIRED = 'SELLER_PRE_APPROVAL_REQUIRED'
    SELLER_PRE_APPROVAL_NOT_REQUIRED = 'SELLER_PRE_APPROVAL_NOT_REQUIRED'


class CreativeSafeFrameCompatibility(Enum):
    CREATIVE_SAFE_FRAME_COMPATIBILITY_UNSPECIFIED = (
        'CREATIVE_SAFE_FRAME_COMPATIBILITY_UNSPECIFIED'
    )
    COMPATIBLE = 'COMPATIBLE'
    INCOMPATIBLE = 'INCOMPATIBLE'


class ProgrammaticCreativeSource(Enum):
    PROGRAMMATIC_CREATIVE_SOURCE_UNSPECIFIED = (
        'PROGRAMMATIC_CREATIVE_SOURCE_UNSPECIFIED'
    )
    ADVERTISER = 'ADVERTISER'
    PUBLISHER = 'PUBLISHER'


class SkippableAdType(Enum):
    SKIPPABLE_AD_TYPE_UNSPECIFIED = 'SKIPPABLE_AD_TYPE_UNSPECIFIED'
    SKIPPABLE = 'SKIPPABLE'
    INSTREAM_SELECT = 'INSTREAM_SELECT'
    NOT_SKIPPABLE = 'NOT_SKIPPABLE'
    ANY = 'ANY'


class CreativeRequirements(BaseModel):
    creativeFormat: Optional[CreativeFormat] = Field(
        None,
        description='Output only. The format of the creative, only applicable for programmatic guaranteed and preferred deals.',
    )
    creativePreApprovalPolicy: Optional[CreativePreApprovalPolicy] = Field(
        None, description='Output only. Specifies the creative pre-approval policy.'
    )
    creativeSafeFrameCompatibility: Optional[CreativeSafeFrameCompatibility] = Field(
        None,
        description='Output only. Specifies whether the creative is safeFrame compatible.',
    )
    maxAdDurationMs: Optional[str] = Field(
        None,
        description='Output only. The max duration of the video creative in milliseconds. only applicable for deals with video creatives.',
    )
    programmaticCreativeSource: Optional[ProgrammaticCreativeSource] = Field(
        None,
        description='Output only. Specifies the creative source for programmatic deals. PUBLISHER means creative is provided by seller and ADVERTISER means creative is provided by the buyer.',
    )
    skippableAdType: Optional[SkippableAdType] = Field(
        None,
        description='Output only. Skippable video ads allow viewers to skip ads after 5 seconds. Only applicable for deals with video creatives.',
    )


class CriteriaTargeting(BaseModel):
    excludedCriteriaIds: Optional[List[str]] = Field(
        None, description='A list of numeric IDs to be excluded.'
    )
    targetedCriteriaIds: Optional[List[str]] = Field(
        None, description='A list of numeric IDs to be included.'
    )


class DayOfWeek(Enum):
    DAY_OF_WEEK_UNSPECIFIED = 'DAY_OF_WEEK_UNSPECIFIED'
    MONDAY = 'MONDAY'
    TUESDAY = 'TUESDAY'
    WEDNESDAY = 'WEDNESDAY'
    THURSDAY = 'THURSDAY'
    FRIDAY = 'FRIDAY'
    SATURDAY = 'SATURDAY'
    SUNDAY = 'SUNDAY'


class TimeZoneType(Enum):
    TIME_ZONE_TYPE_UNSPECIFIED = 'TIME_ZONE_TYPE_UNSPECIFIED'
    SELLER = 'SELLER'
    USER = 'USER'


class DeactivateClientRequest(BaseModel):
    pass


class DeactivateClientUserRequest(BaseModel):
    pass


class DealType(Enum):
    DEAL_TYPE_UNSPECIFIED = 'DEAL_TYPE_UNSPECIFIED'
    PREFERRED_DEAL = 'PREFERRED_DEAL'
    PRIVATE_AUCTION = 'PRIVATE_AUCTION'
    PROGRAMMATIC_GUARANTEED = 'PROGRAMMATIC_GUARANTEED'


class PauseRole(Enum):
    BUYER_SELLER_ROLE_UNSPECIFIED = 'BUYER_SELLER_ROLE_UNSPECIFIED'
    BUYER = 'BUYER'
    SELLER = 'SELLER'


class DealPausingInfo(BaseModel):
    pauseReason: Optional[str] = Field(
        None,
        description='The reason for the pausing of the deal; empty for active deals.',
    )
    pauseRole: Optional[PauseRole] = Field(
        None,
        description='The party that first paused the deal; unspecified for active deals.',
    )
    pausingConsented: Optional[bool] = Field(
        None,
        description='Whether pausing is consented between buyer and seller for the deal.',
    )


class CompanionDeliveryType(Enum):
    COMPANION_DELIVERY_TYPE_UNSPECIFIED = 'COMPANION_DELIVERY_TYPE_UNSPECIFIED'
    DELIVERY_OPTIONAL = 'DELIVERY_OPTIONAL'
    DELIVERY_AT_LEAST_ONE = 'DELIVERY_AT_LEAST_ONE'
    DELIVERY_ALL = 'DELIVERY_ALL'


class CreativeRotationType(Enum):
    CREATIVE_ROTATION_TYPE_UNSPECIFIED = 'CREATIVE_ROTATION_TYPE_UNSPECIFIED'
    ROTATION_EVEN = 'ROTATION_EVEN'
    ROTATION_OPTIMIZED = 'ROTATION_OPTIMIZED'
    ROTATION_MANUAL = 'ROTATION_MANUAL'
    ROTATION_SEQUENTIAL = 'ROTATION_SEQUENTIAL'


class DeliveryRateType(Enum):
    DELIVERY_RATE_TYPE_UNSPECIFIED = 'DELIVERY_RATE_TYPE_UNSPECIFIED'
    EVENLY = 'EVENLY'
    FRONT_LOADED = 'FRONT_LOADED'
    AS_FAST_AS_POSSIBLE = 'AS_FAST_AS_POSSIBLE'


class RoadblockingType(Enum):
    ROADBLOCKING_TYPE_UNSPECIFIED = 'ROADBLOCKING_TYPE_UNSPECIFIED'
    ONLY_ONE = 'ONLY_ONE'
    ONE_OR_MORE = 'ONE_OR_MORE'
    AS_MANY_AS_POSSIBLE = 'AS_MANY_AS_POSSIBLE'
    ALL_ROADBLOCK = 'ALL_ROADBLOCK'
    CREATIVE_SET = 'CREATIVE_SET'


class Empty(BaseModel):
    pass


class DealServingStatus(Enum):
    DEAL_SERVING_STATUS_UNSPECIFIED = 'DEAL_SERVING_STATUS_UNSPECIFIED'
    ACTIVE = 'ACTIVE'
    ENDED = 'ENDED'
    PAUSED_BY_BUYER = 'PAUSED_BY_BUYER'
    PAUSED_BY_SELLER = 'PAUSED_BY_SELLER'


class FirstPartyMobileApplicationTargeting(BaseModel):
    excludedAppIds: Optional[List[str]] = Field(
        None, description='A list of application IDs to be excluded.'
    )
    targetedAppIds: Optional[List[str]] = Field(
        None, description='A list of application IDs to be included.'
    )


class TimeUnitType(Enum):
    TIME_UNIT_TYPE_UNSPECIFIED = 'TIME_UNIT_TYPE_UNSPECIFIED'
    MINUTE = 'MINUTE'
    HOUR = 'HOUR'
    DAY = 'DAY'
    WEEK = 'WEEK'
    MONTH = 'MONTH'
    LIFETIME = 'LIFETIME'
    POD = 'POD'
    STREAM = 'STREAM'


class FrequencyCap(BaseModel):
    maxImpressions: Optional[int] = Field(
        None,
        description='The maximum number of impressions that can be served to a user within the specified time period.',
    )
    timeUnitType: Optional[TimeUnitType] = Field(
        None,
        description='The time unit. Along with num_time_units defines the amount of time over which impressions per user are counted and capped.',
    )
    timeUnitsCount: Optional[int] = Field(
        None,
        description='The amount of time, in the units specified by time_unit_type. Defines the amount of time over which impressions per user are counted and capped.',
    )


class InventorySizeTargeting(BaseModel):
    excludedInventorySizes: Optional[List[AdSize]] = Field(
        None, description='A list of inventory sizes to be excluded.'
    )
    targetedInventorySizes: Optional[List[AdSize]] = Field(
        None, description='A list of inventory sizes to be included.'
    )


class InventoryType(Enum):
    INVENTORY_TYPE_UNSPECIFIED = 'INVENTORY_TYPE_UNSPECIFIED'
    BROWSER = 'BROWSER'
    MOBILE_APP = 'MOBILE_APP'
    VIDEO_PLAYER = 'VIDEO_PLAYER'


class InventoryTypeTargeting(BaseModel):
    inventoryTypes: Optional[List[InventoryType]] = Field(
        None, description='The list of targeted inventory types for the bid request.'
    )


class ListAuctionPackagesResponse(BaseModel):
    auctionPackages: Optional[List[AuctionPackage]] = Field(
        None, description='The list of auction packages.'
    )
    nextPageToken: Optional[str] = Field(
        None,
        description='Continuation token for fetching the next page of results. Pass this value in the ListAuctionPackagesRequest.pageToken field in the subsequent call to the `ListAuctionPackages` method to retrieve the next page of results.',
    )


class ListClientUsersResponse(BaseModel):
    clientUsers: Optional[List[ClientUser]] = Field(
        None, description='The returned list of client users.'
    )
    nextPageToken: Optional[str] = Field(
        None,
        description='A token to retrieve the next page of results. Pass this value in the ListClientUsersRequest.pageToken field in the subsequent call to the list method to retrieve the next page of results.',
    )


class ListClientsResponse(BaseModel):
    clients: Optional[List[Client]] = Field(
        None, description='The returned list of clients.'
    )
    nextPageToken: Optional[str] = Field(
        None,
        description='A token to retrieve the next page of results. Pass this value in the ListClientsRequest.pageToken field in the subsequent call to the list method to retrieve the next page of results.',
    )


class MobileApplicationTargeting(BaseModel):
    firstPartyTargeting: Optional[FirstPartyMobileApplicationTargeting] = Field(
        None,
        description='Publisher owned apps to be targeted or excluded by the publisher to display the ads in.',
    )


class Money(BaseModel):
    currencyCode: Optional[str] = Field(
        None, description='The three-letter currency code defined in ISO 4217.'
    )
    nanos: Optional[int] = Field(
        None,
        description='Number of nano (10^-9) units of the amount. The value must be between -999,999,999 and +999,999,999 inclusive. If `units` is positive, `nanos` must be positive or zero. If `units` is zero, `nanos` can be positive, zero, or negative. If `units` is negative, `nanos` must be negative or zero. For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.',
    )
    units: Optional[str] = Field(
        None,
        description='The whole units of the amount. For example if `currencyCode` is `"USD"`, then 1 unit is one US dollar.',
    )


class CreatorRole(Enum):
    BUYER_SELLER_ROLE_UNSPECIFIED = 'BUYER_SELLER_ROLE_UNSPECIFIED'
    BUYER = 'BUYER'
    SELLER = 'SELLER'


class Note(BaseModel):
    createTime: Optional[str] = Field(
        None, description='Output only. When this note was created.'
    )
    creatorRole: Optional[CreatorRole] = Field(
        None, description='Output only. The role who created the note.'
    )
    note: Optional[str] = Field(
        None, description='The text of the note. Maximum length is 1024 characters.'
    )


class OperatingSystemTargeting(BaseModel):
    operatingSystemCriteria: Optional[CriteriaTargeting] = Field(
        None, description='IDs of operating systems to be included/excluded.'
    )
    operatingSystemVersionCriteria: Optional[CriteriaTargeting] = Field(
        None, description='IDs of operating system versions to be included/excluded.'
    )


class PauseFinalizedDealRequest(BaseModel):
    reason: Optional[str] = Field(
        None,
        description='The reason to pause the finalized deal, will be displayed to the seller. Maximum length is 1000 characters.',
    )


class Type1(Enum):
    TYPE_UNSPECIFIED = 'TYPE_UNSPECIFIED'
    CPM = 'CPM'
    CPD = 'CPD'


class Price(BaseModel):
    amount: Optional[Money] = Field(
        None, description='The actual price with currency specified.'
    )
    type: Optional[Type1] = Field(None, description='The pricing type for the deal.')


class PrivateAuctionTerms(BaseModel):
    floorPrice: Optional[Price] = Field(
        None,
        description='The minimum price buyer has to bid to compete in the private auction.',
    )
    openAuctionAllowed: Optional[bool] = Field(
        None,
        description='Output only. True if open auction buyers are allowed to compete with invited buyers in this private auction.',
    )


class PrivateData(BaseModel):
    referenceId: Optional[str] = Field(
        None,
        description='A buyer specified reference ID. This can be queried in the list operations (max-length: 1024 unicode code units).',
    )


class ReservationType(Enum):
    RESERVATION_TYPE_UNSPECIFIED = 'RESERVATION_TYPE_UNSPECIFIED'
    STANDARD = 'STANDARD'
    SPONSORSHIP = 'SPONSORSHIP'


class ProgrammaticGuaranteedTerms(BaseModel):
    fixedPrice: Optional[Price] = Field(None, description='Fixed price for the deal.')
    guaranteedLooks: Optional[str] = Field(
        None, description='Count of guaranteed looks.'
    )
    impressionCap: Optional[str] = Field(
        None,
        description='The lifetime impression cap for CPM Sponsorship deals. Deal will stop serving when cap is reached.',
    )
    minimumDailyLooks: Optional[str] = Field(
        None, description='Daily minimum looks for CPD deal types.'
    )
    percentShareOfVoice: Optional[str] = Field(
        None,
        description="For sponsorship deals, this is the percentage of the seller's eligible impressions that the deal will serve until the cap is reached. Valid value is within range 0~100.",
    )
    reservationType: Optional[ReservationType] = Field(
        None,
        description='The reservation type for a Programmatic Guaranteed deal. This indicates whether the number of impressions is fixed, or a percent of available impressions. If not specified, the default reservation type is STANDARD.',
    )


class LastUpdaterOrCommentorRole(Enum):
    BUYER_SELLER_ROLE_UNSPECIFIED = 'BUYER_SELLER_ROLE_UNSPECIFIED'
    BUYER = 'BUYER'
    SELLER = 'SELLER'


class OriginatorRole(Enum):
    BUYER_SELLER_ROLE_UNSPECIFIED = 'BUYER_SELLER_ROLE_UNSPECIFIED'
    BUYER = 'BUYER'
    SELLER = 'SELLER'


class State2(Enum):
    STATE_UNSPECIFIED = 'STATE_UNSPECIFIED'
    BUYER_REVIEW_REQUESTED = 'BUYER_REVIEW_REQUESTED'
    SELLER_REVIEW_REQUESTED = 'SELLER_REVIEW_REQUESTED'
    BUYER_ACCEPTANCE_REQUESTED = 'BUYER_ACCEPTANCE_REQUESTED'
    FINALIZED = 'FINALIZED'
    TERMINATED = 'TERMINATED'


class Proposal(BaseModel):
    billedBuyer: Optional[str] = Field(
        None,
        description='Output only. When the client field is populated, this field refers to the buyer who creates and manages the client buyer and gets billed on behalf of the client buyer; when the buyer field is populated, this field is the same value as buyer. Format : `buyers/{buyerAccountId}`',
    )
    buyer: Optional[str] = Field(
        None,
        description='Output only. Refers to a buyer in The Realtime-bidding API. Format: `buyers/{buyerAccountId}`',
    )
    buyerContacts: Optional[List[Contact]] = Field(
        None, description='Contact information for the buyer.'
    )
    buyerPrivateData: Optional[PrivateData] = Field(
        None, description='Buyer private data (hidden from seller).'
    )
    client: Optional[str] = Field(
        None,
        description='Output only. Refers to a Client. Format: `buyers/{buyerAccountId}/clients/{clientAccountid}`',
    )
    dealType: Optional[DealType] = Field(
        None, description='Output only. Type of deal the proposal contains.'
    )
    displayName: Optional[str] = Field(
        None,
        description='Output only. The descriptive name for the proposal. Maximum length of 255 unicode characters is allowed. Control characters are not allowed. Buyers cannot update this field. Note: Not to be confused with name, which is a unique identifier of the proposal.',
    )
    isRenegotiating: Optional[bool] = Field(
        None,
        description='Output only. True if the proposal was previously finalized and is now being renegotiated.',
    )
    lastUpdaterOrCommentorRole: Optional[LastUpdaterOrCommentorRole] = Field(
        None,
        description='Output only. The role of the last user that either updated the proposal or left a comment.',
    )
    name: Optional[str] = Field(
        None,
        description='Immutable. The name of the proposal serving as a unique identifier. Format: buyers/{accountId}/proposals/{proposalId}',
    )
    notes: Optional[List[Note]] = Field(
        None,
        description='A list of notes from the buyer and the seller attached to this proposal.',
    )
    originatorRole: Optional[OriginatorRole] = Field(
        None,
        description='Output only. Indicates whether the buyer/seller created the proposal.',
    )
    pausingConsented: Optional[bool] = Field(
        None,
        description='Whether pausing is allowed for the proposal. This is a negotiable term between buyers and publishers.',
    )
    proposalRevision: Optional[str] = Field(
        None,
        description='Output only. The revision number for the proposal. Each update to the proposal or deal causes the proposal revision number to auto-increment. The buyer keeps track of the last revision number they know of and pass it in when making an update. If the head revision number on the server has since incremented, then an ABORTED error is returned during the update operation to let the buyer know that a subsequent update was made.',
    )
    publisherProfile: Optional[str] = Field(
        None,
        description='Immutable. Reference to the seller on the proposal. Format: `buyers/{buyerAccountId}/publisherProfiles/{publisherProfileId}` Note: This field may be set only when creating the resource. Modifying this field while updating the resource will result in an error.',
    )
    sellerContacts: Optional[List[Contact]] = Field(
        None, description='Output only. Contact information for the seller.'
    )
    state: Optional[State2] = Field(
        None, description='Output only. Indicates the state of the proposal.'
    )
    termsAndConditions: Optional[str] = Field(
        None,
        description='Output only. The terms and conditions associated with this proposal. Accepting a proposal implies acceptance of this field. This is created by the seller, the buyer can only view it.',
    )
    updateTime: Optional[str] = Field(
        None, description='Output only. The time when the proposal was last revised.'
    )


class AppStore(Enum):
    APP_STORE_TYPE_UNSPECIFIED = 'APP_STORE_TYPE_UNSPECIFIED'
    APPLE_ITUNES = 'APPLE_ITUNES'
    GOOGLE_PLAY = 'GOOGLE_PLAY'
    ROKU = 'ROKU'
    AMAZON_FIRE_TV = 'AMAZON_FIRE_TV'
    PLAYSTATION = 'PLAYSTATION'
    XBOX = 'XBOX'
    SAMSUNG_TV = 'SAMSUNG_TV'
    AMAZON = 'AMAZON'
    OPPO = 'OPPO'
    SAMSUNG = 'SAMSUNG'
    VIVO = 'VIVO'
    XIAOMI = 'XIAOMI'


class PublisherProfileMobileApplication(BaseModel):
    appStore: Optional[AppStore] = Field(
        None,
        description='The app store the app belongs to. Can be used to filter the response of the publisherProfiles.list method.',
    )
    externalAppId: Optional[str] = Field(
        None,
        description='The external ID for the app from its app store. Can be used to filter the response of the publisherProfiles.list method.',
    )
    name: Optional[str] = Field(None, description='The name of the app.')


class ResumeFinalizedDealRequest(BaseModel):
    pass


class RtbMetrics(BaseModel):
    adImpressions7Days: Optional[str] = Field(
        None, description='Ad impressions in last 7 days.'
    )
    bidRate7Days: Optional[float] = Field(
        None,
        description='Bid rate in last 7 days, calculated by (bids / bid requests).',
    )
    bidRequests7Days: Optional[str] = Field(
        None, description='Bid requests in last 7 days.'
    )
    bids7Days: Optional[str] = Field(None, description='Bids in last 7 days.')
    filteredBidRate7Days: Optional[float] = Field(
        None,
        description='Filtered bid rate in last 7 days, calculated by (filtered bids / bids).',
    )
    mustBidRateCurrentMonth: Optional[float] = Field(
        None, description='Must bid rate for current month.'
    )


class SetReadyToServeRequest(BaseModel):
    pass


class SubscribeAuctionPackageRequest(BaseModel):
    pass


class SubscribeClientsRequest(BaseModel):
    clients: Optional[List[str]] = Field(
        None,
        description='Optional. A list of client buyers to subscribe to the auction package, with client buyer in the format `buyers/{accountId}/clients/{clientAccountId}`. The current buyer will be subscribed to the auction package regardless of the list contents if not already.',
    )


class TechnologyTargeting(BaseModel):
    deviceCapabilityTargeting: Optional[CriteriaTargeting] = Field(
        None, description='IDs of device capabilities to be included/excluded.'
    )
    deviceCategoryTargeting: Optional[CriteriaTargeting] = Field(
        None, description='IDs of device categories to be included/excluded.'
    )
    operatingSystemTargeting: Optional[OperatingSystemTargeting] = Field(
        None, description='Operating system related targeting information.'
    )


class TimeOfDay(BaseModel):
    hours: Optional[int] = Field(
        None,
        description='Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.',
    )
    minutes: Optional[int] = Field(
        None, description='Minutes of hour of day. Must be from 0 to 59.'
    )
    nanos: Optional[int] = Field(
        None,
        description='Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.',
    )
    seconds: Optional[int] = Field(
        None,
        description='Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.',
    )


class TimeZone(BaseModel):
    id: Optional[str] = Field(
        None, description='IANA Time Zone Database time zone, e.g. "America/New_York".'
    )
    version: Optional[str] = Field(
        None,
        description='Optional. IANA Time Zone Database version number, e.g. "2019a".',
    )


class UnsubscribeAuctionPackageRequest(BaseModel):
    pass


class UnsubscribeClientsRequest(BaseModel):
    clients: Optional[List[str]] = Field(
        None,
        description='Optional. A list of client buyers to unsubscribe from the auction package, with client buyer in the format `buyers/{accountId}/clients/{clientAccountId}`.',
    )


class UriTargeting(BaseModel):
    excludedUris: Optional[List[str]] = Field(
        None, description='A list of URLs to be excluded.'
    )
    targetedUris: Optional[List[str]] = Field(
        None, description='A list of URLs to be included.'
    )


class ExcludedPositionType(Enum):
    POSITION_TYPE_UNSPECIFIED = 'POSITION_TYPE_UNSPECIFIED'
    PREROLL = 'PREROLL'
    MIDROLL = 'MIDROLL'
    POSTROLL = 'POSTROLL'


class TargetedPositionType(Enum):
    POSITION_TYPE_UNSPECIFIED = 'POSITION_TYPE_UNSPECIFIED'
    PREROLL = 'PREROLL'
    MIDROLL = 'MIDROLL'
    POSTROLL = 'POSTROLL'


class VideoTargeting(BaseModel):
    excludedPositionTypes: Optional[List[ExcludedPositionType]] = Field(
        None,
        description='A list of video positions to be excluded. When this field is populated, the targeted_position_types field must be empty.',
    )
    targetedPositionTypes: Optional[List[TargetedPositionType]] = Field(
        None,
        description='A list of video positions to be included. When this field is populated, the excluded_position_types field must be empty.',
    )


class FieldXgafv(Enum):
    field_1 = '1'
    field_2 = '2'


class Alt(Enum):
    json = 'json'
    media = 'media'
    proto = 'proto'


class AddNoteRequest(BaseModel):
    note: Optional[Note] = Field(None, description='The note to add.')


class DayPart(BaseModel):
    dayOfWeek: Optional[DayOfWeek] = Field(
        None, description='Day of week for the period.'
    )
    endTime: Optional[TimeOfDay] = Field(
        None,
        description='Hours in 24 hour time between 0 and 24, inclusive. Note: 24 is logically equivalent to 0, but is supported since in some cases there may need to be differentiation made between midnight on one day and midnight on the next day. Accepted values for minutes are [0, 15, 30, 45]. 0 is the only acceptable minute value for hour 24. Seconds and nanos are ignored.',
    )
    startTime: Optional[TimeOfDay] = Field(
        None,
        description='Hours in 24 hour time between 0 and 24, inclusive. Note: 24 is logically equivalent to 0, but is supported since in some cases there may need to be differentiation made between midnight on one day and midnight on the next day. Accepted values for minutes are [0, 15, 30, 45]. 0 is the only acceptable minute value for hour 24. Seconds and nanos are ignored.',
    )


class DayPartTargeting(BaseModel):
    dayParts: Optional[List[DayPart]] = Field(
        None, description='The targeted weekdays and times'
    )
    timeZoneType: Optional[TimeZoneType] = Field(
        None, description='The time zone type of the day parts'
    )


class DeliveryControl(BaseModel):
    companionDeliveryType: Optional[CompanionDeliveryType] = Field(
        None,
        description='Output only. Specifies roadblocking in a main companion lineitem.',
    )
    creativeRotationType: Optional[CreativeRotationType] = Field(
        None,
        description='Output only. Specifies strategy to use for selecting a creative when multiple creatives of the same size are available.',
    )
    deliveryRateType: Optional[DeliveryRateType] = Field(
        None,
        description='Output only. Specifies how the impression delivery will be paced.',
    )
    frequencyCap: Optional[List[FrequencyCap]] = Field(
        None,
        description='Output only. Specifies any frequency caps. Cannot be filtered within ListDealsRequest.',
    )
    roadblockingType: Optional[RoadblockingType] = Field(
        None,
        description='Output only. Specifies the roadblocking type in display creatives.',
    )


class ListProposalsResponse(BaseModel):
    nextPageToken: Optional[str] = Field(
        None, description='Continuation token for fetching the next page of results.'
    )
    proposals: Optional[List[Proposal]] = Field(
        None, description='The list of proposals.'
    )


class PlacementTargeting(BaseModel):
    mobileApplicationTargeting: Optional[MobileApplicationTargeting] = Field(
        None,
        description="Mobile application targeting information in a deal. This doesn't apply to Auction Packages.",
    )
    uriTargeting: Optional[UriTargeting] = Field(
        None, description='URLs to be included/excluded.'
    )


class PreferredDealTerms(BaseModel):
    fixedPrice: Optional[Price] = Field(None, description='Fixed price for the deal.')


class PublisherProfile(BaseModel):
    audienceDescription: Optional[str] = Field(
        None, description="Description on the publisher's audience."
    )
    directDealsContact: Optional[str] = Field(
        None,
        description='Contact information for direct reservation deals. This is free text entered by the publisher and may include information like names, phone numbers and email addresses.',
    )
    displayName: Optional[str] = Field(
        None,
        description='Display name of the publisher profile. Can be used to filter the response of the publisherProfiles.list method.',
    )
    domains: Optional[List[str]] = Field(
        None,
        description='The list of domains represented in this publisher profile. Empty if this is a parent profile. These are top private domains, meaning that these will not contain a string like "photos.google.co.uk/123", but will instead contain "google.co.uk". Can be used to filter the response of the publisherProfiles.list method.',
    )
    isParent: Optional[bool] = Field(
        None,
        description='Indicates if this profile is the parent profile of the seller. A parent profile represents all the inventory from the seller, as opposed to child profile that is created to brand a portion of inventory. One seller has only one parent publisher profile, and can have multiple child profiles. See https://support.google.com/admanager/answer/6035806 for details. Can be used to filter the response of the publisherProfiles.list method by setting the filter to "is_parent: true".',
    )
    logoUrl: Optional[str] = Field(
        None,
        description='A Google public URL to the logo for this publisher profile. The logo is stored as a PNG, JPG, or GIF image.',
    )
    mediaKitUrl: Optional[str] = Field(
        None, description='URL to additional marketing and sales materials.'
    )
    mobileApps: Optional[List[PublisherProfileMobileApplication]] = Field(
        None,
        description='The list of apps represented in this publisher profile. Empty if this is a parent profile.',
    )
    name: Optional[str] = Field(
        None,
        description='Name of the publisher profile. Format: `buyers/{buyer}/publisherProfiles/{publisher_profile}`',
    )
    overview: Optional[str] = Field(None, description='Overview of the publisher.')
    pitchStatement: Optional[str] = Field(
        None,
        description="Statement explaining what's unique about publisher's business, and why buyers should partner with the publisher.",
    )
    programmaticDealsContact: Optional[str] = Field(
        None,
        description='Contact information for programmatic deals. This is free text entered by the publisher and may include information like names, phone numbers and email addresses.',
    )
    publisherCode: Optional[str] = Field(
        None,
        description="A unique identifying code for the seller. This value is the same for all of the seller's parent and child publisher profiles. Can be used to filter the response of the publisherProfiles.list method.",
    )
    samplePageUrl: Optional[str] = Field(
        None, description='URL to a sample content page.'
    )
    topHeadlines: Optional[List[str]] = Field(
        None,
        description='Up to three key metrics and rankings. For example, "#1 Mobile News Site for 20 Straight Months".',
    )


class SendRfpRequest(BaseModel):
    buyerContacts: Optional[List[Contact]] = Field(
        None, description='Contact information for the buyer.'
    )
    client: Optional[str] = Field(
        None,
        description='If the current buyer is sending the RFP on behalf of its client, use this field to specify the name of the client in the format: `buyers/{accountId}/clients/{clientAccountid}`.',
    )
    displayName: Optional[str] = Field(
        None,
        description='Required. The display name of the proposal being created by this RFP.',
    )
    estimatedGrossSpend: Optional[Money] = Field(
        None,
        description='Specified by buyers in request for proposal (RFP) to notify publisher the total estimated spend for the proposal. Publishers will receive this information and send back proposed deals accordingly.',
    )
    flightEndTime: Optional[str] = Field(
        None,
        description='Required. Proposed flight end time of the RFP. A timestamp in RFC3339 UTC "Zulu" format. Note that the specified value will be truncated to a granularity of one second.',
    )
    flightStartTime: Optional[str] = Field(
        None,
        description='Required. Proposed flight start time of the RFP. A timestamp in RFC3339 UTC "Zulu" format. Note that the specified value will be truncated to a granularity of one second.',
    )
    geoTargeting: Optional[CriteriaTargeting] = Field(
        None, description='Geo criteria IDs to be targeted. Refer to Geo tables.'
    )
    inventorySizeTargeting: Optional[InventorySizeTargeting] = Field(
        None, description='Inventory sizes to be targeted.'
    )
    note: Optional[str] = Field(
        None,
        description='A message that is sent to the publisher. Maximum length is 1024 characters.',
    )
    preferredDealTerms: Optional[PreferredDealTerms] = Field(
        None, description='The terms for preferred deals.'
    )
    programmaticGuaranteedTerms: Optional[ProgrammaticGuaranteedTerms] = Field(
        None, description='The terms for programmatic guaranteed deals.'
    )
    publisherProfile: Optional[str] = Field(
        None,
        description='Required. The profile of the publisher who will receive this RFP in the format: `buyers/{accountId}/publisherProfiles/{publisherProfileId}`.',
    )


class ListPublisherProfilesResponse(BaseModel):
    nextPageToken: Optional[str] = Field(
        None, description='Token to fetch the next page of results.'
    )
    publisherProfiles: Optional[List[PublisherProfile]] = Field(
        None, description='The list of matching publisher profiles.'
    )


class MarketplaceTargeting(BaseModel):
    daypartTargeting: Optional[DayPartTargeting] = Field(
        None, description='Daypart targeting information.'
    )
    geoTargeting: Optional[CriteriaTargeting] = Field(
        None, description='Output only. Geo criteria IDs to be included/excluded.'
    )
    inventorySizeTargeting: Optional[InventorySizeTargeting] = Field(
        None, description='Output only. Inventory sizes to be included/excluded.'
    )
    inventoryTypeTargeting: Optional[InventoryTypeTargeting] = Field(
        None, description='Output only. Inventory type targeting information.'
    )
    placementTargeting: Optional[PlacementTargeting] = Field(
        None,
        description='Output only. Placement targeting information, for example, URL, mobile applications.',
    )
    technologyTargeting: Optional[TechnologyTargeting] = Field(
        None,
        description='Output only. Technology targeting information, for example, operating system, device category.',
    )
    userListTargeting: Optional[CriteriaTargeting] = Field(
        None,
        description='Buyer user list targeting information. User lists can be uploaded using https://developers.google.com/authorized-buyers/rtb/bulk-uploader.',
    )
    videoTargeting: Optional[VideoTargeting] = Field(
        None, description='Output only. Video targeting information.'
    )


class Deal(BaseModel):
    billedBuyer: Optional[str] = Field(
        None,
        description='Output only. When the client field is populated, this field refers to the buyer who creates and manages the client buyer and gets billed on behalf of the client buyer; when the buyer field is populated, this field is the same value as buyer. Format : `buyers/{buyerAccountId}`',
    )
    buyer: Optional[str] = Field(
        None,
        description='Output only. Refers to a buyer in The Realtime-bidding API. Format: `buyers/{buyerAccountId}`',
    )
    client: Optional[str] = Field(
        None,
        description='Output only. Refers to a Client. Format: `buyers/{buyerAccountId}/clients/{clientAccountid}`',
    )
    createTime: Optional[str] = Field(
        None, description='Output only. The time of the deal creation.'
    )
    creativeRequirements: Optional[CreativeRequirements] = Field(
        None, description='Output only. Metadata about the creatives of this deal.'
    )
    dealType: Optional[DealType] = Field(None, description='Output only. Type of deal.')
    deliveryControl: Optional[DeliveryControl] = Field(
        None, description='Output only. Specifies the pacing set by the publisher.'
    )
    description: Optional[str] = Field(
        None, description='Output only. Free text description for the deal terms.'
    )
    displayName: Optional[str] = Field(
        None,
        description='Output only. The name of the deal. Maximum length of 255 unicode characters is allowed. Control characters are not allowed. Buyers cannot update this field. Note: Not to be confused with name, which is a unique identifier of the deal.',
    )
    estimatedGrossSpend: Optional[Money] = Field(
        None,
        description='Specified by buyers in request for proposal (RFP) to notify publisher the total estimated spend for the proposal. Publishers will receive this information and send back proposed deals accordingly.',
    )
    flightEndTime: Optional[str] = Field(
        None,
        description='Proposed flight end time of the deal. This will generally be stored in a granularity of a second. A value is not necessary for Private Auction deals.',
    )
    flightStartTime: Optional[str] = Field(
        None,
        description='Proposed flight start time of the deal. This will generally be stored in the granularity of one second since deal serving starts at seconds boundary. Any time specified with more granularity (for example, in milliseconds) will be truncated towards the start of time in seconds.',
    )
    name: Optional[str] = Field(
        None,
        description='Immutable. The unique identifier of the deal. Auto-generated by the server when a deal is created. Format: buyers/{accountId}/proposals/{proposalId}/deals/{dealId}',
    )
    preferredDealTerms: Optional[PreferredDealTerms] = Field(
        None, description='The terms for preferred deals.'
    )
    privateAuctionTerms: Optional[PrivateAuctionTerms] = Field(
        None, description='The terms for private auction deals.'
    )
    programmaticGuaranteedTerms: Optional[ProgrammaticGuaranteedTerms] = Field(
        None, description='The terms for programmatic guaranteed deals.'
    )
    proposalRevision: Optional[str] = Field(
        None,
        description='Output only. The revision number for the proposal and is the same value as proposal.proposal_revision. Each update to deal causes the proposal revision number to auto-increment. The buyer keeps track of the last revision number they know of and pass it in when making an update. If the head revision number on the server has since incremented, then an ABORTED error is returned during the update operation to let the buyer know that a subsequent update was made.',
    )
    publisherProfile: Optional[str] = Field(
        None,
        description='Immutable. Reference to the seller on the deal. Format: `buyers/{buyerAccountId}/publisherProfiles/{publisherProfileId}`',
    )
    sellerTimeZone: Optional[TimeZone] = Field(
        None,
        description='Output only. Time zone of the seller used to mark the boundaries of a day for daypart targeting and CPD billing.',
    )
    targeting: Optional[MarketplaceTargeting] = Field(
        None,
        description='Specifies the subset of inventory targeted by the deal. Can be updated by the buyer before the deal is finalized.',
    )
    updateTime: Optional[str] = Field(
        None, description='Output only. The time when the deal was last updated.'
    )


class FinalizedDeal(BaseModel):
    deal: Optional[Deal] = Field(
        None,
        description='A copy of the Deal made upon finalization. During renegotiation, this will reflect the last finalized deal before renegotiation was initiated.',
    )
    dealPausingInfo: Optional[DealPausingInfo] = Field(
        None, description='Information related to deal pausing for the deal.'
    )
    dealServingStatus: Optional[DealServingStatus] = Field(
        None, description='Serving status of the deal.'
    )
    name: Optional[str] = Field(
        None,
        description='The resource name of the finalized deal. Format: `buyers/{accountId}/finalizeddeals/{finalizedDealId}`',
    )
    readyToServe: Optional[bool] = Field(
        None,
        description='Whether the Programmatic Guaranteed deal is ready for serving.',
    )
    rtbMetrics: Optional[RtbMetrics] = Field(
        None, description='Real-time bidding metrics for this deal.'
    )


class ListDealsResponse(BaseModel):
    deals: Optional[List[Deal]] = Field(None, description='The list of deals.')
    nextPageToken: Optional[str] = Field(
        None, description='Token to fetch the next page of results.'
    )


class ListFinalizedDealsResponse(BaseModel):
    finalizedDeals: Optional[List[FinalizedDeal]] = Field(
        None, description='The list of finalized deals.'
    )
    nextPageToken: Optional[str] = Field(
        None, description='Token to fetch the next page of results.'
    )


class UpdateDealRequest(BaseModel):
    deal: Optional[Deal] = Field(
        None,
        description="Required. The deal to update. The deal's `name` field is used to identify the deal to be updated. Note: proposal_revision will have to be provided within the resource or else an error will be thrown. Format: buyers/{accountId}/proposals/{proposalId}/deals/{dealId}",
    )
    updateMask: Optional[str] = Field(
        None,
        description='List of fields to be updated. If empty or unspecified, the service will update all fields populated in the update request excluding the output only fields and primitive fields with default value. Note that explicit field mask is required in order to reset a primitive field back to its default value, for example, false for boolean fields, 0 for integer fields. A special field mask consisting of a single path "*" can be used to indicate full replacement(the equivalent of PUT method), updatable fields unset or unspecified in the input will be cleared or set to default value. Output only fields will be ignored regardless of the value of updateMask.',
    )


class BatchUpdateDealsRequest(BaseModel):
    requests: Optional[List[UpdateDealRequest]] = Field(
        None, description='Required. List of request messages to update deals.'
    )


class BatchUpdateDealsResponse(BaseModel):
    deals: Optional[List[Deal]] = Field(None, description='Deals updated.')
